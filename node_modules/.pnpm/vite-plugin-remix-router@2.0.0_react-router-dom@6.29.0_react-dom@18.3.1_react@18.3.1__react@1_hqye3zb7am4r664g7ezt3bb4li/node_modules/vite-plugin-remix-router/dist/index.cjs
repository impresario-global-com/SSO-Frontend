'use strict';

const path = require('path');
const fs = require('fs');
const vite = require('vite');

const defaultOptions = {
  routesDirectory: "src/routes",
  extensions: ["tsx", "jsx"]
};
let resolvedOptions = null;
function resolveOptions(root, userOptions) {
  return {
    root: root ?? vite.normalizePath(process.cwd()),
    ...defaultOptions,
    ...userOptions
  };
}
function setOptions(options) {
  resolvedOptions = options;
}
function getOptions() {
  if (resolvedOptions === null) {
    throw new Error('Something went wrong. Unable to resolve "UserOptions".');
  }
  return resolvedOptions;
}

function isDirectory(filePath) {
  return fs.statSync(filePath).isDirectory();
}
function isCatchAllRoute(s) {
  return s === "$";
}
function isDynamicRoute(s) {
  return s.startsWith("$");
}
function parameterizeDynamicRoute(s) {
  return s.replace(/^\$(.+)$/, (_, p) => `:${p}`);
}
function normalizeFilenameToRoute(filename) {
  const MATCH_ALL_ROUTE = "*";
  if (isCatchAllRoute(filename)) {
    return MATCH_ALL_ROUTE;
  }
  if (isDynamicRoute(filename)) {
    return parameterizeDynamicRoute(filename);
  }
  return filename;
}
function toAbsolutePath(filePath) {
  return path.join(getOptions().root, filePath);
}

class RouteNode {
  constructor(filePath) {
    this.children = [];
    this.name = path.parse(filePath).name;
    this.path = filePath;
  }
}
function buildRouteTree() {
  const root = createNode(getOptions().routesDirectory);
  root.isDirectory = true;
  root.name = "/";
  return root;
}
function createNode(filePath) {
  const node = new RouteNode(filePath);
  if (isDirectory(toAbsolutePath(filePath))) {
    node.isDirectory = true;
    node.layoutPath = getLayoutPath(filePath);
    const children = resolveChildren(toAbsolutePath(filePath));
    node.children = children.map((child) => createNode(`${filePath}/${child}`));
  }
  return node;
}
function getLayoutPath(directoryPath) {
  return getOptions().extensions.map((extension) => `${directoryPath}.${extension}`).find((filePath) => fs.existsSync(toAbsolutePath(filePath)));
}
function resolveChildren(directoryPath) {
  const children = fs.readdirSync(directoryPath);
  return children.filter((child) => {
    const childPath = path.join(directoryPath, child);
    if (isDirectory(childPath)) {
      return true;
    }
    if (isLayout(childPath)) {
      return false;
    }
    const extension = path.extname(childPath);
    return getOptions().extensions.includes(extension.substring(1));
  });
}
function isLayout(filePath) {
  return fs.existsSync(filePath.split(".").slice(0, -1).join("."));
}

const VIRTUAL_MODULE_ID = "virtual:routes";
const RESOLVED_VIRTUAL_MODULE_ID = `\0${VIRTUAL_MODULE_ID}`;

let imports = [];
function generateRoutesModule(rootNode) {
  imports = [];
  const routes = createRouteObject(rootNode);
  const code = [];
  code.push("import React from 'react';");
  code.push(...imports);
  code.push("");
  const routesString = JSON.stringify(routes, null, 2).replace(/\\"/g, '"').replace(/("::|::")/g, "");
  code.push(`export const routes = [${routesString}]
`);
  return code.join("\n");
}
function createRouteObject(node) {
  if (node.isDirectory) {
    return createLayoutRoute(node);
  }
  return createPageRoute(node);
}
function createLayoutRoute(node) {
  return {
    lazy: node.layoutPath ? createLazyRoute(
      node.layoutPath
    ) : void 0,
    path: node.name.startsWith("__") ? void 0 : normalizeFilenameToRoute(node.name),
    children: node.children.map((child) => createRouteObject(child))
  };
}
function createPageRoute(node) {
  const path = node.name === "index" ? { index: true } : { path: normalizeFilenameToRoute(node.name) };
  return {
    ...path,
    lazy: createLazyRoute(
      node.path
    )
  };
}
function createLazyRoute(filePath) {
  return `::() => import("/${filePath}")::`;
}

function Plugin(userOptions) {
  let routeTree;
  return {
    name: "vite-plugin-remix-router",
    enforce: "pre",
    configResolved({ root }) {
      setOptions(resolveOptions(root, userOptions));
      routeTree = buildRouteTree();
    },
    configureServer(server) {
      server.watcher.on("unlink", (filePath) => {
        if (!isRouteFile(filePath)) {
          return;
        }
        routeTree = buildRouteTree();
        reloadServer(server);
      });
      server.watcher.on("add", (filePath) => {
        if (!isRouteFile(filePath)) {
          return;
        }
        routeTree = buildRouteTree();
        reloadServer(server);
      });
      server.watcher.on("change", (filePath) => {
        if (!isRouteFile(filePath)) {
          return;
        }
        reloadServer(server);
      });
    },
    resolveId(id) {
      if (id === VIRTUAL_MODULE_ID) {
        return RESOLVED_VIRTUAL_MODULE_ID;
      }
      return null;
    },
    load(id) {
      if (id === RESOLVED_VIRTUAL_MODULE_ID) {
        return generateRoutesModule(routeTree);
      }
      return null;
    }
  };
}
function isRouteFile(filePath) {
  return filePath.startsWith(path.resolve(getOptions().routesDirectory)) && getOptions().extensions.some((ext) => filePath.endsWith(ext));
}
function reloadServer(server) {
  const { moduleGraph } = server;
  const module = moduleGraph.getModuleById(RESOLVED_VIRTUAL_MODULE_ID);
  if (module) {
    moduleGraph.invalidateModule(module);
  }
  server.ws.send({
    type: "full-reload"
  });
}

module.exports = Plugin;
