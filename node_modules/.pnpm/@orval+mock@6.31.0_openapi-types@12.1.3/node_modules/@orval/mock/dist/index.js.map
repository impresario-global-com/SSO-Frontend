{"version":3,"sources":["../src/index.ts","../src/msw/index.ts","../src/delay.ts","../src/faker/getters/combine.ts","../src/faker/resolvers/value.ts","../src/faker/getters/scalar.ts","../src/faker/constants.ts","../src/faker/getters/object.ts","../src/faker/getters/route.ts","../src/msw/mocks.ts"],"sourcesContent":["import {\n  GenerateMockImports,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  GlobalMockOptions,\n} from '@orval/core';\nimport { generateMSW, generateMSWImports } from './msw';\n\nexport const DEFAULT_MOCK_OPTIONS: GlobalMockOptions = {\n  type: 'msw',\n  useExamples: false,\n};\n\nexport const generateMockImports: GenerateMockImports = (importOptions) => {\n  switch (importOptions.options?.type) {\n    default: // case 'msw':\n      return generateMSWImports(importOptions);\n  }\n};\n\nexport const generateMock = (\n  generatorVerbOptions: GeneratorVerbOptions,\n  generatorOptions: Omit<GeneratorOptions, 'mock'> & {\n    mock: GlobalMockOptions;\n  },\n) => {\n  switch (generatorOptions.mock.type) {\n    default: // case 'msw':\n      return generateMSW(generatorVerbOptions, generatorOptions);\n  }\n};\n","import {\n  ClientMockGeneratorBuilder,\n  generateDependencyImports,\n  GenerateMockImports,\n  GeneratorDependency,\n  GeneratorImport,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  isFunction,\n  isObject,\n  pascal,\n  ResReqTypesValue,\n} from '@orval/core';\nimport { getDelay } from '../delay';\nimport { getRouteMSW, overrideVarName } from '../faker/getters';\nimport { getMockDefinition, getMockOptionsDataOverride } from './mocks';\n\nconst getMSWDependencies = (locale?: string): GeneratorDependency[] => [\n  {\n    exports: [\n      { name: 'http', values: true },\n      { name: 'HttpResponse', values: true },\n      { name: 'delay', values: true },\n    ],\n    dependency: 'msw',\n  },\n  {\n    exports: [{ name: 'faker', values: true }],\n    dependency: locale ? `@faker-js/faker/locale/${locale}` : '@faker-js/faker',\n  },\n];\n\nexport const generateMSWImports: GenerateMockImports = ({\n  implementation,\n  imports,\n  specsName,\n  hasSchemaDir,\n  isAllowSyntheticDefaultImports,\n  options,\n}) => {\n  return generateDependencyImports(\n    implementation,\n    [...getMSWDependencies(options?.locale), ...imports],\n    specsName,\n    hasSchemaDir,\n    isAllowSyntheticDefaultImports,\n  );\n};\n\nconst generateDefinition = (\n  name: string,\n  route: string,\n  getResponseMockFunctionNameBase: string,\n  handlerNameBase: string,\n  { operationId, response, verb, tags }: GeneratorVerbOptions,\n  { override, context, mock }: GeneratorOptions,\n  returnType: string,\n  status: string,\n  responseImports: GeneratorImport[],\n  responses: ResReqTypesValue[],\n  contentTypes: string[],\n  splitMockImplementations: string[],\n) => {\n  const oldSplitMockImplementations = [...splitMockImplementations];\n  const { definitions, definition, imports } = getMockDefinition({\n    operationId,\n    tags,\n    returnType,\n    responses,\n    imports: responseImports,\n    override,\n    context,\n    mockOptions: !isFunction(mock) ? mock : undefined,\n    splitMockImplementations,\n  });\n\n  const mockData = getMockOptionsDataOverride(operationId, override);\n\n  let value = '';\n\n  if (mockData) {\n    value = mockData;\n  } else if (definitions.length > 1) {\n    value = `faker.helpers.arrayElement(${definition})`;\n  } else if (definitions[0]) {\n    value = definitions[0];\n  }\n\n  const isResponseOverridable = value.includes(overrideVarName);\n  const isTextPlain = contentTypes.includes('text/plain');\n  const isReturnHttpResponse = value && value !== 'undefined';\n\n  const getResponseMockFunctionName = `${getResponseMockFunctionNameBase}${pascal(\n    name,\n  )}`;\n  const handlerName = `${handlerNameBase}${pascal(name)}`;\n\n  const addedSplitMockImplementations = splitMockImplementations.slice(\n    oldSplitMockImplementations.length,\n  );\n  splitMockImplementations.push(...addedSplitMockImplementations);\n  const mockImplementations = addedSplitMockImplementations.length\n    ? `${addedSplitMockImplementations.join('\\n\\n')}\\n\\n`\n    : '';\n\n  const mockImplementation = isReturnHttpResponse\n    ? `${mockImplementations}export const ${getResponseMockFunctionName} = (${\n        isResponseOverridable\n          ? `overrideResponse: Partial< ${returnType} > = {}`\n          : ''\n      })${mockData ? '' : `: ${returnType}`} => (${value})\\n\\n`\n    : mockImplementations;\n\n  const delay = getDelay(override, !isFunction(mock) ? mock : undefined);\n  const isHandlerOverridden = isReturnHttpResponse && !isTextPlain;\n  const infoParam = isHandlerOverridden ? 'info' : '';\n  const handlerImplementation = `\nexport const ${handlerName} = (${\n    isHandlerOverridden\n      ? `overrideResponse?: ${returnType} | ((${infoParam}: Parameters<Parameters<typeof http.${verb}>[1]>[0]) => Promise<${returnType}> | ${returnType})`\n      : ''\n  }) => {\n  return http.${verb}('${route}', ${\n    (isReturnHttpResponse && !isTextPlain) || delay !== false ? 'async' : ''\n  } (${infoParam}) => {${\n    delay !== false\n      ? `await delay(${isFunction(delay) ? `(${delay})()` : delay});`\n      : ''\n  }\n    return new HttpResponse(${\n      isReturnHttpResponse\n        ? isTextPlain\n          ? `${getResponseMockFunctionName}()`\n          : `JSON.stringify(overrideResponse !== undefined \n            ? (typeof overrideResponse === \"function\" ? await overrideResponse(${infoParam}) : overrideResponse) \n            : ${getResponseMockFunctionName}())`\n        : null\n    },\n      {\n        status: ${status === 'default' ? 200 : status.replace(/XX$/, '00')},\n        headers: {\n          'Content-Type': '${isTextPlain ? 'text/plain' : 'application/json'}',\n        }\n      }\n    )\n  })\n}\\n`;\n\n  const includeResponseImports =\n    isReturnHttpResponse && !isTextPlain\n      ? [\n          ...imports,\n          ...response.imports.filter((r) => {\n            // Only include imports which are actually used in mock.\n            const reg = new RegExp(`\\\\b${r.name}\\\\b`);\n            return (\n              reg.test(handlerImplementation) || reg.test(mockImplementation)\n            );\n          }),\n        ]\n      : imports;\n\n  return {\n    implementation: {\n      function: mockImplementation,\n      handlerName: handlerName,\n      handler: handlerImplementation,\n    },\n    imports: includeResponseImports,\n  };\n};\n\nexport const generateMSW = (\n  generatorVerbOptions: GeneratorVerbOptions,\n  generatorOptions: GeneratorOptions,\n): ClientMockGeneratorBuilder => {\n  const { pathRoute, override, mock } = generatorOptions;\n  const { operationId, response } = generatorVerbOptions;\n\n  const route = getRouteMSW(\n    pathRoute,\n    override?.mock?.baseUrl ?? (!isFunction(mock) ? mock?.baseUrl : undefined),\n  );\n\n  const handlerName = `get${pascal(operationId)}MockHandler`;\n  const getResponseMockFunctionName = `get${pascal(operationId)}ResponseMock`;\n\n  const splitMockImplementations: string[] = [];\n\n  const baseDefinition = generateDefinition(\n    '',\n    route,\n    getResponseMockFunctionName,\n    handlerName,\n    generatorVerbOptions,\n    generatorOptions,\n    response.definition.success,\n    response.types.success[0]?.key ?? '200',\n    response.imports,\n    response.types.success,\n    response.contentTypes,\n    splitMockImplementations,\n  );\n\n  const mockImplementations = [baseDefinition.implementation.function];\n  const handlerImplementations = [baseDefinition.implementation.handler];\n  const imports = [...baseDefinition.imports];\n\n  if (\n    generatorOptions.mock &&\n    isObject(generatorOptions.mock) &&\n    generatorOptions.mock.generateEachHttpStatus\n  ) {\n    [...response.types.success, ...response.types.errors].forEach(\n      (statusResponse) => {\n        const definition = generateDefinition(\n          statusResponse.key,\n          route,\n          getResponseMockFunctionName,\n          handlerName,\n          generatorVerbOptions,\n          generatorOptions,\n          statusResponse.value,\n          statusResponse.key,\n          response.imports,\n          [statusResponse],\n          [statusResponse.contentType],\n          splitMockImplementations,\n        );\n        mockImplementations.push(definition.implementation.function);\n        handlerImplementations.push(definition.implementation.handler);\n        imports.push(...definition.imports);\n      },\n    );\n  }\n\n  return {\n    implementation: {\n      function: mockImplementations.join('\\n'),\n      handlerName: handlerName,\n      handler: handlerImplementations.join('\\n'),\n    },\n    imports: imports,\n  };\n};\n","import { GlobalMockOptions, NormalizedOverrideOutput } from '@orval/core';\n\nexport const getDelay = (\n  override?: NormalizedOverrideOutput,\n  options?: GlobalMockOptions,\n): GlobalMockOptions['delay'] => {\n  const overrideDelay =\n    override?.mock?.delay !== undefined\n      ? override?.mock?.delay\n      : options?.delay;\n  const delayFunctionLazyExecute =\n    override?.mock?.delayFunctionLazyExecute ??\n    options?.delayFunctionLazyExecute;\n  switch (typeof overrideDelay) {\n    case 'function':\n      return delayFunctionLazyExecute ? overrideDelay : overrideDelay();\n    case 'number':\n    case 'boolean':\n      return overrideDelay;\n    default:\n      return 1000;\n  }\n};\n","import {\n  ContextSpecs,\n  GeneratorImport,\n  isReference,\n  MockOptions,\n} from '@orval/core';\nimport omit from 'lodash.omit';\nimport { MockDefinition, MockSchemaObject } from '../../types';\nimport { resolveMockValue } from '../resolvers';\n\nexport const combineSchemasMock = ({\n  item,\n  separator,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n}: {\n  item: MockSchemaObject;\n  separator: 'allOf' | 'oneOf' | 'anyOf';\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n}): MockDefinition => {\n  let combineImports: GeneratorImport[] = [];\n  let includedProperties: string[] = (combine?.includedProperties ?? []).slice(\n    0,\n  );\n\n  const isRefAndNotExisting =\n    isReference(item) && !existingReferencedProperties.includes(item.name);\n\n  const itemResolvedValue =\n    isRefAndNotExisting || item.properties\n      ? resolveMockValue({\n          schema: omit(item, separator) as MockSchemaObject,\n          combine: {\n            separator: 'allOf',\n            includedProperties: [],\n          },\n          mockOptions,\n          operationId,\n          tags,\n          context,\n          imports,\n          existingReferencedProperties,\n          splitMockImplementations,\n        })\n      : undefined;\n\n  includedProperties.push(...(itemResolvedValue?.includedProperties ?? []));\n  combineImports.push(...(itemResolvedValue?.imports ?? []));\n\n  const value = (item[separator] ?? []).reduce((acc, val, index, arr) => {\n    if (\n      '$ref' in val &&\n      existingReferencedProperties.includes(val.$ref.split('/').pop()!)\n    ) {\n      if (arr.length === 1) {\n        return 'undefined';\n      }\n\n      return acc;\n    }\n\n    const resolvedValue = resolveMockValue({\n      schema: {\n        ...val,\n        name: item.name,\n        path: item.path ? item.path : '#',\n      },\n      combine: {\n        separator,\n        includedProperties:\n          separator !== 'oneOf'\n            ? includedProperties\n            : itemResolvedValue?.includedProperties ?? [],\n      },\n      mockOptions,\n      operationId,\n      tags,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n\n    combineImports.push(...resolvedValue.imports);\n    includedProperties.push(...(resolvedValue.includedProperties ?? []));\n\n    const isLastElement = index === arr.length - 1;\n\n    let currentValue = resolvedValue.value;\n\n    if (itemResolvedValue?.value && separator === 'oneOf') {\n      const splitValues = resolvedValue.value.split('},{');\n      const joined = splitValues.join(`,${itemResolvedValue.value}},{`);\n      currentValue = `${joined.slice(0, -1)},${itemResolvedValue.value}}`;\n    }\n\n    if (itemResolvedValue?.value && separator !== 'oneOf' && isLastElement) {\n      currentValue = `${currentValue ? `${currentValue},` : ''}${itemResolvedValue.value}`;\n    }\n\n    const isObjectBounds =\n      !combine || (combine.separator === 'oneOf' && separator === 'allOf');\n\n    if (!index && isObjectBounds) {\n      if (\n        resolvedValue.enums ||\n        separator === 'oneOf' ||\n        separator === 'anyOf' ||\n        resolvedValue.type === 'array'\n      ) {\n        if (arr.length === 1) {\n          return `faker.helpers.arrayElement([${currentValue}])`;\n        }\n        return `faker.helpers.arrayElement([${currentValue},`;\n      }\n\n      if (arr.length === 1) {\n        if (resolvedValue.type && resolvedValue.type !== 'object') {\n          return currentValue;\n        }\n        return `{${currentValue}}`;\n      }\n\n      return `{${currentValue},`;\n    }\n\n    if (isLastElement) {\n      if (\n        resolvedValue.enums ||\n        separator === 'oneOf' ||\n        separator === 'anyOf' ||\n        resolvedValue.type === 'array'\n      ) {\n        return `${acc}${currentValue}${!combine ? '])' : ''}`;\n      }\n\n      return `${acc}${currentValue}${isObjectBounds ? '}' : ''}`;\n    }\n\n    if (!currentValue) {\n      return acc;\n    }\n\n    return `${acc}${currentValue},`;\n  }, '');\n\n  return {\n    value: value,\n    imports: combineImports,\n    name: item.name,\n    includedProperties,\n  };\n};\n","import {\n  ContextSpecs,\n  GeneratorImport,\n  getRefInfo,\n  isReference,\n  isRootKey,\n  MockOptions,\n  pascal,\n} from '@orval/core';\nimport get from 'lodash.get';\nimport { SchemaObject } from 'openapi3-ts/oas30';\nimport { MockDefinition, MockSchemaObject } from '../../types';\nimport { overrideVarName } from '../getters';\nimport { getMockScalar } from '../getters/scalar';\n\nconst isRegex = (key: string) => key[0] === '/' && key[key.length - 1] === '/';\n\nexport const resolveMockOverride = (\n  properties: Record<string, unknown> | undefined = {},\n  item: SchemaObject & { name: string; path?: string },\n) => {\n  const path = item.path ? item.path : `#.${item.name}`;\n  const property = Object.entries(properties).find(([key]) => {\n    if (isRegex(key)) {\n      const regex = new RegExp(key.slice(1, key.length - 1));\n      if (regex.test(item.name) || regex.test(path)) {\n        return true;\n      }\n    }\n\n    if (`#.${key}` === path) {\n      return true;\n    }\n\n    return false;\n  });\n\n  if (!property) {\n    return;\n  }\n\n  return {\n    value: getNullable(property[1] as string, item.nullable),\n    imports: [],\n    name: item.name,\n    overrided: true,\n  };\n};\n\nexport const getNullable = (value: string, nullable?: boolean) =>\n  nullable ? `faker.helpers.arrayElement([${value}, null])` : value;\n\nexport const resolveMockValue = ({\n  schema,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride,\n}: {\n  schema: MockSchemaObject;\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  allowOverride?: boolean;\n}): MockDefinition & { type?: string } => {\n  if (isReference(schema)) {\n    const {\n      name,\n      specKey = context.specKey,\n      refPaths,\n    } = getRefInfo(schema.$ref, context);\n\n    const schemaRef = get(context.specs[specKey], refPaths as string[]);\n\n    const newSchema = {\n      ...schemaRef,\n      name,\n      path: schema.path,\n      isRef: true,\n    };\n\n    const scalar = getMockScalar({\n      item: newSchema,\n      mockOptions,\n      operationId,\n      tags,\n      combine,\n      context: {\n        ...context,\n        specKey,\n      },\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n      allowOverride,\n    });\n    if (\n      scalar.value &&\n      (newSchema.type === 'object' || newSchema.allOf) &&\n      combine?.separator === 'oneOf'\n    ) {\n      const funcName = `get${pascal(operationId)}Response${pascal(newSchema.name)}Mock`;\n      if (\n        !splitMockImplementations?.some((f) =>\n          f.includes(`export const ${funcName}`),\n        )\n      ) {\n        const discriminatedProperty = newSchema.discriminator?.propertyName;\n\n        let type = `Partial<${newSchema.name}>`;\n        if (discriminatedProperty) {\n          type = `Omit<${type}, '${discriminatedProperty}'>`;\n        }\n\n        const args = `${overrideVarName}: ${type} = {}`;\n        const value = newSchema.oneOf\n          ? `faker.helpers.arrayElement([${scalar.value}])`\n          : scalar.value;\n        const func = `export const ${funcName} = (${args}): ${newSchema.name} => ({...${value}, ...${overrideVarName}});`;\n        splitMockImplementations?.push(func);\n      }\n      scalar.value = `{...${funcName}()}`;\n      scalar.imports.push({\n        name: newSchema.name,\n        specKey: isRootKey(specKey, context.target) ? undefined : specKey,\n      });\n    }\n\n    return {\n      ...scalar,\n      type: newSchema.type,\n    };\n  }\n\n  const scalar = getMockScalar({\n    item: schema,\n    mockOptions,\n    operationId,\n    tags,\n    combine,\n    context,\n    imports,\n    existingReferencedProperties,\n    splitMockImplementations,\n    allowOverride,\n  });\n\n  return {\n    ...scalar,\n    type: schema.type,\n  };\n};\n","import {\n  ContextSpecs,\n  escape,\n  GeneratorImport,\n  isReference,\n  isRootKey,\n  mergeDeep,\n  MockOptions,\n} from '@orval/core';\nimport { MockDefinition, MockSchemaObject } from '../../types';\nimport { DEFAULT_FORMAT_MOCK } from '../constants';\nimport {\n  getNullable,\n  resolveMockOverride,\n  resolveMockValue,\n} from '../resolvers';\nimport { getMockObject } from './object';\n\nexport const getMockScalar = ({\n  item,\n  imports,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride = false,\n}: {\n  item: MockSchemaObject;\n  imports: GeneratorImport[];\n  mockOptions?: MockOptions;\n  operationId: string;\n  isRef?: boolean;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  // This is used to add the overrideResponse to the object\n  allowOverride?: boolean;\n}): MockDefinition => {\n  // Add the property to the existing properties to validate on object recursion\n  if (item.isRef) {\n    existingReferencedProperties = [...existingReferencedProperties, item.name];\n  }\n\n  const operationProperty = resolveMockOverride(\n    mockOptions?.operations?.[operationId]?.properties,\n    item,\n  );\n\n  if (operationProperty) {\n    return operationProperty;\n  }\n\n  const overrideTag = Object.entries(mockOptions?.tags ?? {})\n    .sort((a, b) => {\n      return a[0].localeCompare(b[0]);\n    })\n    .reduce(\n      (acc, [tag, options]) =>\n        tags.includes(tag) ? mergeDeep(acc, options) : acc,\n      {} as { properties: Record<string, unknown> },\n    );\n\n  const tagProperty = resolveMockOverride(overrideTag?.properties, item);\n\n  if (tagProperty) {\n    return tagProperty;\n  }\n\n  const property = resolveMockOverride(mockOptions?.properties, item);\n\n  if (property) {\n    return property;\n  }\n\n  if (\n    (context.output.override?.mock?.useExamples || mockOptions?.useExamples) &&\n    item.example\n  ) {\n    return {\n      value: JSON.stringify(item.example),\n      imports: [],\n      name: item.name,\n      overrided: true,\n    };\n  }\n\n  const ALL_FORMAT = {\n    ...DEFAULT_FORMAT_MOCK,\n    ...(mockOptions?.format ?? {}),\n  };\n\n  if (item.format && ALL_FORMAT[item.format]) {\n    return {\n      value: getNullable(`${ALL_FORMAT[item.format]}`, item.nullable),\n      imports: [],\n      name: item.name,\n      overrided: false,\n    };\n  }\n\n  switch (item.type) {\n    case 'number':\n    case 'integer': {\n      let value = getNullable(\n        `faker.number.int({min: ${item.minimum}, max: ${item.maximum}})`,\n        item.nullable,\n      );\n      let numberImports: GeneratorImport[] = [];\n      if (item.enum) {\n        // By default the value isn't a reference, so we don't have the object explicitly defined.\n        // So we have to create an array with the enum values and force them to be a const.\n        const joinedEnumValues = item.enum.filter(Boolean).join(',');\n\n        let enumValue = `[${joinedEnumValues}] as const`;\n\n        // But if the value is a reference, we can use the object directly via the imports and using Object.values.\n        if (item.isRef) {\n          enumValue = `Object.values(${item.name})`;\n          numberImports = [\n            {\n              name: item.name,\n              values: true,\n              ...(!isRootKey(context.specKey, context.target)\n                ? { specKey: context.specKey }\n                : {}),\n            },\n          ];\n        }\n\n        value = item.path?.endsWith('[]')\n          ? `faker.helpers.arrayElements(${enumValue})`\n          : `faker.helpers.arrayElement(${enumValue})`;\n      }\n      return {\n        value,\n        imports: numberImports,\n        name: item.name,\n      };\n    }\n\n    case 'boolean': {\n      return {\n        value: 'faker.datatype.boolean()',\n        imports: [],\n        name: item.name,\n      };\n    }\n\n    case 'array': {\n      if (!item.items) {\n        return { value: '[]', imports: [], name: item.name };\n      }\n\n      if (\n        '$ref' in item.items &&\n        existingReferencedProperties.includes(item.items.$ref.split('/').pop()!)\n      ) {\n        return { value: '[]', imports: [], name: item.name };\n      }\n\n      const {\n        value,\n        enums,\n        imports: resolvedImports,\n        name,\n      } = resolveMockValue({\n        schema: {\n          ...item.items,\n          name: item.name,\n          path: item.path ? `${item.path}.[]` : '#.[]',\n        },\n        combine,\n        mockOptions,\n        operationId,\n        tags,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n      });\n\n      if (enums) {\n        if (!isReference(item.items)) {\n          return {\n            value,\n            imports: resolvedImports,\n            name: item.name,\n          };\n        }\n\n        const enumImp = imports.find(\n          (imp) => name.replace('[]', '') === imp.name,\n        );\n        const enumValue = enumImp?.name || name;\n        return {\n          value: `faker.helpers.arrayElements(Object.values(${enumValue}))`,\n          imports: enumImp\n            ? [\n                ...resolvedImports,\n                {\n                  ...enumImp,\n                  values: true,\n                  ...(!isRootKey(context.specKey, context.target)\n                    ? { specKey: context.specKey }\n                    : {}),\n                },\n              ]\n            : resolvedImports,\n          name: item.name,\n        };\n      }\n\n      let mapValue = value;\n\n      if (combine && !value.startsWith('faker') && !value.startsWith('{')) {\n        mapValue = `{${value}}`;\n      }\n\n      return {\n        value:\n          `Array.from({ length: faker.number.int({ ` +\n          `min: ${mockOptions?.arrayMin}, ` +\n          `max: ${mockOptions?.arrayMax} }) ` +\n          `}, (_, i) => i + 1).map(() => (${mapValue}))`,\n        imports: resolvedImports,\n        name: item.name,\n      };\n    }\n\n    case 'string': {\n      let value = 'faker.word.sample()';\n      let imports: GeneratorImport[] = [];\n\n      if (item.enum) {\n        // By default the value isn't a reference, so we don't have the object explicitly defined.\n        // So we have to create an array with the enum values and force them to be a const.\n        const joindEnumValues = item.enum\n          .filter(Boolean)\n          .map((e) => escape(e))\n          .join(\"','\");\n\n        let enumValue = `['${joindEnumValues}'] as const`;\n\n        // But if the value is a reference, we can use the object directly via the imports and using Object.values.\n        if (item.isRef) {\n          enumValue = `Object.values(${item.name})`;\n          imports = [\n            {\n              name: item.name,\n              values: true,\n              ...(!isRootKey(context.specKey, context.target)\n                ? { specKey: context.specKey }\n                : {}),\n            },\n          ];\n        }\n\n        value = item.path?.endsWith('[]')\n          ? `faker.helpers.arrayElements(${enumValue})`\n          : `faker.helpers.arrayElement(${enumValue})`;\n      } else if (item.pattern) {\n        value = `faker.helpers.fromRegExp('${item.pattern}')`;\n      }\n\n      return {\n        value: getNullable(value, item.nullable),\n        enums: item.enum,\n        name: item.name,\n        imports,\n      };\n    }\n\n    case 'null':\n      return {\n        value: 'null',\n        imports: [],\n        name: item.name,\n      };\n\n    default: {\n      return getMockObject({\n        item,\n        mockOptions,\n        operationId,\n        tags,\n        combine,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n        allowOverride,\n      });\n    }\n  }\n};\n","import { SchemaObject } from 'openapi3-ts/oas30';\n\nexport const DEFAULT_FORMAT_MOCK: Record<\n  Required<SchemaObject>['format'],\n  string\n> = {\n  bic: 'faker.finance.bic()',\n  binary:\n    \"new Blob(faker.helpers.arrayElements(faker.word.words(10).split(' ')))\",\n  city: 'faker.location.city()',\n  country: 'faker.location.country()',\n  date: \"faker.date.past().toISOString().split('T')[0]\",\n  'date-time': \"`${faker.date.past().toISOString().split('.')[0]}Z`\",\n  email: 'faker.internet.email()',\n  firstName: 'faker.person.firstName()',\n  gender: 'faker.person.gender()',\n  iban: 'faker.finance.iban()',\n  ipv4: 'faker.internet.ipv4()',\n  ipv6: 'faker.internet.ipv6()',\n  jobTitle: 'faker.person.jobTitle()',\n  lastName: 'faker.person.lastName()',\n  password: 'faker.internet.password()',\n  phoneNumber: 'faker.phone.number()',\n  streetName: 'faker.location.street()',\n  uri: 'faker.internet.url()',\n  url: 'faker.internet.url()',\n  userName: 'faker.internet.userName()',\n  uuid: 'faker.string.uuid()',\n  zipCode: 'faker.location.zipCode()',\n};\n\n// #980 replace CUID so tests are consistent\nexport const DEFAULT_OBJECT_KEY_MOCK = 'faker.string.alphanumeric(5)';\n","import {\n  ContextSpecs,\n  GeneratorImport,\n  getKey,\n  isBoolean,\n  isReference,\n  MockOptions,\n} from '@orval/core';\nimport { ReferenceObject, SchemaObject } from 'openapi3-ts/oas30';\nimport { resolveMockValue } from '../resolvers/value';\nimport { MockDefinition, MockSchemaObject } from '../../types';\nimport { combineSchemasMock } from './combine';\nimport { DEFAULT_OBJECT_KEY_MOCK } from '../constants';\n\nexport const overrideVarName = 'overrideResponse';\n\nexport const getMockObject = ({\n  item,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride = false,\n}: {\n  item: MockSchemaObject;\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  // This is used to add the overrideResponse to the object\n  allowOverride?: boolean;\n}): MockDefinition => {\n  if (isReference(item)) {\n    return resolveMockValue({\n      schema: {\n        ...item,\n        name: item.name,\n        path: item.path ? `${item.path}.${item.name}` : item.name,\n      },\n      mockOptions,\n      operationId,\n      tags,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (item.allOf || item.oneOf || item.anyOf) {\n    const separator = item.allOf ? 'allOf' : item.oneOf ? 'oneOf' : 'anyOf';\n    return combineSchemasMock({\n      item,\n      separator,\n      mockOptions,\n      operationId,\n      tags,\n      combine,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (Array.isArray(item.type)) {\n    return combineSchemasMock({\n      item: {\n        anyOf: item.type.map((type) => ({ type })),\n        name: item.name,\n      },\n      separator: 'anyOf',\n      mockOptions,\n      operationId,\n      tags,\n      combine,\n      context,\n      imports,\n      existingReferencedProperties,\n    });\n  }\n\n  if (item.properties) {\n    let value =\n      !combine ||\n      combine?.separator === 'oneOf' ||\n      combine?.separator === 'anyOf'\n        ? '{'\n        : '';\n    let imports: GeneratorImport[] = [];\n    let includedProperties: string[] = [];\n\n    const properyScalars = Object.entries(item.properties)\n      .sort((a, b) => {\n        return a[0].localeCompare(b[0]);\n      })\n      .map(([key, prop]: [string, ReferenceObject | SchemaObject]) => {\n        if (combine?.includedProperties.includes(key)) {\n          return undefined;\n        }\n\n        const isRequired =\n          mockOptions?.required ||\n          (Array.isArray(item.required) ? item.required : []).includes(key);\n\n        // Check to see if the property is a reference to an existing property\n        // Fixes issue #910\n        if (\n          '$ref' in prop &&\n          existingReferencedProperties.includes(prop.$ref.split('/').pop()!)\n        ) {\n          return undefined;\n        }\n\n        const resolvedValue = resolveMockValue({\n          schema: {\n            ...prop,\n            name: key,\n            path: item.path ? `${item.path}.${key}` : `#.${key}`,\n          },\n          mockOptions,\n          operationId,\n          tags,\n          context,\n          imports,\n          existingReferencedProperties,\n          splitMockImplementations,\n        });\n\n        imports.push(...resolvedValue.imports);\n        includedProperties.push(key);\n\n        const keyDefinition = getKey(key);\n        if (!isRequired && !resolvedValue.overrided) {\n          return `${keyDefinition}: faker.helpers.arrayElement([${resolvedValue.value}, undefined])`;\n        }\n\n        return `${keyDefinition}: ${resolvedValue.value}`;\n      })\n      .filter(Boolean);\n\n    if (allowOverride) {\n      properyScalars.push(`...${overrideVarName}`);\n    }\n\n    value += properyScalars.join(', ');\n    value +=\n      !combine ||\n      combine?.separator === 'oneOf' ||\n      combine?.separator === 'anyOf'\n        ? '}'\n        : '';\n\n    return {\n      value,\n      imports,\n      name: item.name,\n      includedProperties,\n    };\n  }\n\n  if (item.additionalProperties) {\n    if (isBoolean(item.additionalProperties)) {\n      return { value: `{}`, imports: [], name: item.name };\n    }\n    if (\n      isReference(item.additionalProperties) &&\n      existingReferencedProperties.includes(\n        item.additionalProperties.$ref.split('/').pop()!,\n      )\n    ) {\n      return { value: `{}`, imports: [], name: item.name };\n    }\n\n    const resolvedValue = resolveMockValue({\n      schema: {\n        ...item.additionalProperties,\n        name: item.name,\n        path: item.path ? `${item.path}.#` : '#',\n      },\n      mockOptions,\n      operationId,\n      tags,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n\n    return {\n      ...resolvedValue,\n      value: `{\n        [${DEFAULT_OBJECT_KEY_MOCK}]: ${resolvedValue.value}\n      }`,\n    };\n  }\n\n  return { value: '{}', imports: [], name: item.name };\n};\n","import { camel, sanitize } from '@orval/core';\n\nconst hasParam = (path: string): boolean => /[^{]*{[\\w*_-]*}.*/.test(path);\n\nconst getRoutePath = (path: string): string => {\n  const matches = path.match(/([^{]*){?([\\w*_-]*)}?(.*)/);\n  if (!matches?.length) return path; // impossible due to regexp grouping here, but for TS\n\n  const prev = matches[1];\n  const param = sanitize(camel(matches[2]), {\n    es5keyword: true,\n    underscore: true,\n    dash: true,\n    dot: true,\n  });\n  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];\n\n  if (hasParam(path)) {\n    return `${prev}:${param}${next}`;\n  } else {\n    return `${prev}${param}${next}`;\n  }\n};\n\nexport const getRouteMSW = (route: string, baseUrl = '*') => {\n  const splittedRoute = route.split('/');\n\n  return splittedRoute.reduce((acc, path, i) => {\n    if (!path && !i) {\n      return acc;\n    }\n\n    if (!path.includes('{')) {\n      return `${acc}/${path}`;\n    }\n\n    return `${acc}/${getRoutePath(path)}`;\n  }, baseUrl);\n};\n","import {\n  ContextSpecs,\n  generalJSTypesWithArray,\n  GeneratorImport,\n  GlobalMockOptions,\n  isFunction,\n  MockOptions,\n  NormalizedOverrideOutput,\n  resolveRef,\n  ResReqTypesValue,\n  stringify,\n} from '@orval/core';\nimport { OpenAPIObject, SchemaObject } from 'openapi3-ts/oas30';\nimport { getMockScalar } from '../faker/getters';\n\nconst getMockPropertiesWithoutFunc = (properties: any, spec: OpenAPIObject) =>\n  Object.entries(isFunction(properties) ? properties(spec) : properties).reduce<\n    Record<string, string>\n  >((acc, [key, value]) => {\n    const implementation = isFunction(value)\n      ? `(${value})()`\n      : stringify(value as string)!;\n\n    acc[key] = implementation?.replace(\n      /import_faker.defaults|import_faker.faker/g,\n      'faker',\n    );\n    return acc;\n  }, {});\n\nconst getMockWithoutFunc = (\n  spec: OpenAPIObject,\n  override?: NormalizedOverrideOutput,\n): MockOptions => ({\n  arrayMin: override?.mock?.arrayMin,\n  arrayMax: override?.mock?.arrayMax,\n  required: override?.mock?.required,\n  ...(override?.mock?.properties\n    ? {\n        properties: getMockPropertiesWithoutFunc(\n          override.mock.properties,\n          spec,\n        ),\n      }\n    : {}),\n  ...(override?.mock?.format\n    ? {\n        format: getMockPropertiesWithoutFunc(override.mock.format, spec),\n      }\n    : {}),\n  ...(override?.operations\n    ? {\n        operations: Object.entries(override.operations).reduce<\n          Exclude<MockOptions['operations'], undefined>\n        >((acc, [key, value]) => {\n          if (value.mock?.properties) {\n            acc[key] = {\n              properties: getMockPropertiesWithoutFunc(\n                value.mock.properties,\n                spec,\n              ),\n            };\n          }\n\n          return acc;\n        }, {}),\n      }\n    : {}),\n  ...(override?.tags\n    ? {\n        tags: Object.entries(override.tags).reduce<\n          Exclude<MockOptions['tags'], undefined>\n        >((acc, [key, value]) => {\n          if (value.mock?.properties) {\n            acc[key] = {\n              properties: getMockPropertiesWithoutFunc(\n                value.mock.properties,\n                spec,\n              ),\n            };\n          }\n\n          return acc;\n        }, {}),\n      }\n    : {}),\n});\n\nconst getMockScalarJsTypes = (\n  definition: string,\n  mockOptionsWithoutFunc: { [key: string]: unknown },\n) => {\n  const isArray = definition.endsWith('[]');\n  const type = isArray ? definition.slice(0, -2) : definition;\n\n  switch (type) {\n    case 'number':\n      return isArray\n        ? `Array.from({length: faker.number.int({` +\n            `min: ${mockOptionsWithoutFunc.arrayMin}, ` +\n            `max: ${mockOptionsWithoutFunc.arrayMax}}` +\n            `)}, () => faker.number.int())`\n        : 'faker.number.int()';\n    case 'string':\n      return isArray\n        ? `Array.from({length: faker.number.int({` +\n            `min: ${mockOptionsWithoutFunc?.arrayMin},` +\n            `max: ${mockOptionsWithoutFunc?.arrayMax}}` +\n            `)}, () => faker.word.sample())`\n        : 'faker.word.sample()';\n    default:\n      return 'undefined';\n  }\n};\n\nexport const getResponsesMockDefinition = ({\n  operationId,\n  tags,\n  returnType,\n  responses,\n  imports: responseImports,\n  mockOptionsWithoutFunc,\n  transformer,\n  context,\n  mockOptions,\n  splitMockImplementations,\n}: {\n  operationId: string;\n  tags: string[];\n  returnType: string;\n  responses: ResReqTypesValue[];\n  imports: GeneratorImport[];\n  mockOptionsWithoutFunc: { [key: string]: unknown };\n  transformer?: (value: unknown, definition: string) => string;\n  context: ContextSpecs;\n  mockOptions?: GlobalMockOptions;\n  splitMockImplementations: string[];\n}) => {\n  return responses.reduce(\n    (\n      acc,\n      { value: definition, originalSchema, example, examples, imports, isRef },\n    ) => {\n      if (\n        context.output.override?.mock?.useExamples ||\n        mockOptions?.useExamples\n      ) {\n        let exampleValue =\n          example ||\n          originalSchema?.example ||\n          Object.values(examples || {})[0] ||\n          originalSchema?.examples?.[0];\n        exampleValue = exampleValue?.value ?? exampleValue;\n        if (exampleValue) {\n          acc.definitions.push(\n            transformer\n              ? transformer(exampleValue, returnType)\n              : JSON.stringify(exampleValue),\n          );\n          return acc;\n        }\n      }\n      if (!definition || generalJSTypesWithArray.includes(definition)) {\n        const value = getMockScalarJsTypes(definition, mockOptionsWithoutFunc);\n\n        acc.definitions.push(\n          transformer ? transformer(value, returnType) : value,\n        );\n\n        return acc;\n      }\n\n      if (!originalSchema) {\n        return acc;\n      }\n\n      const resolvedRef = resolveRef<SchemaObject>(originalSchema, context);\n\n      const scalar = getMockScalar({\n        item: {\n          name: definition,\n          ...resolvedRef.schema,\n        },\n        imports,\n        mockOptions: mockOptionsWithoutFunc,\n        operationId,\n        tags,\n        context: isRef\n          ? {\n              ...context,\n              specKey: responseImports[0]?.specKey ?? context.specKey,\n            }\n          : context,\n        existingReferencedProperties: [],\n        splitMockImplementations,\n        allowOverride: true,\n      });\n\n      acc.imports.push(...scalar.imports);\n      acc.definitions.push(\n        transformer\n          ? transformer(scalar.value, returnType)\n          : scalar.value.toString(),\n      );\n\n      return acc;\n    },\n    {\n      definitions: [] as string[],\n      imports: [] as GeneratorImport[],\n    },\n  );\n};\n\nexport const getMockDefinition = ({\n  operationId,\n  tags,\n  returnType,\n  responses,\n  imports: responseImports,\n  override,\n  transformer,\n  context,\n  mockOptions,\n  splitMockImplementations,\n}: {\n  operationId: string;\n  tags: string[];\n  returnType: string;\n  responses: ResReqTypesValue[];\n  imports: GeneratorImport[];\n  override: NormalizedOverrideOutput;\n  transformer?: (value: unknown, definition: string) => string;\n  context: ContextSpecs;\n  mockOptions?: GlobalMockOptions;\n  splitMockImplementations: string[];\n}) => {\n  const mockOptionsWithoutFunc = getMockWithoutFunc(\n    context.specs[context.specKey],\n    override,\n  );\n\n  const { definitions, imports } = getResponsesMockDefinition({\n    operationId,\n    tags,\n    returnType,\n    responses,\n    imports: responseImports,\n    mockOptionsWithoutFunc,\n    transformer,\n    context,\n    mockOptions,\n    splitMockImplementations,\n  });\n\n  return {\n    definition: '[' + definitions.join(', ') + ']',\n    definitions,\n    imports,\n  };\n};\n\nexport const getMockOptionsDataOverride = (\n  operationId: string,\n  override: NormalizedOverrideOutput,\n) => {\n  const responseOverride = override?.operations?.[operationId]?.mock?.data;\n  const implementation = isFunction(responseOverride)\n    ? `(${responseOverride})()`\n    : stringify(responseOverride);\n\n  return implementation?.replace(\n    /import_faker.defaults|import_faker.faker/g,\n    'faker',\n  );\n};\n"],"mappings":"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","names":["import_core","import_core","import_lodash","import_core","import_core","imports","imports","get","scalar","omit","_a","_b","import_core","import_core","_a"]}